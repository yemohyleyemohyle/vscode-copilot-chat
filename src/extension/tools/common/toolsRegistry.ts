/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import type * as vscode from 'vscode';
import { IChatEndpoint } from '../../../platform/networking/common/networking';
import { IDisposable } from '../../../util/vs/base/common/lifecycle';
import { ObservableMap } from '../../../util/vs/base/common/observable';
import { URI } from '../../../util/vs/base/common/uri';
import { IBuildPromptContext } from '../../prompt/common/intents';
import { ToolName } from './toolNames';

export interface IEditFilterData {
	title: string;
	message: string;
}

export enum CopilotToolMode {
	/**
	 * Give a shorter result, agent mode can call again to get more context
	*/
	PartialContext,

	/**
	 * Give a longer result, it gets one shot
	 */
	FullContext,
}

export interface ICopilotToolExtension<T> {
	/**
	 * Called when edits are made in a tool call response. The tool can return
	 * a confirmation that will be shown to the user before edits are applied.
	 */
	filterEdits?(resource: URI): Promise<IEditFilterData | undefined>;

	/**
	 * Called when the tool is referenced in a prompt. If this function is not
	 * provided, Copilot will ask the model to generate the necessary input.
	 */
	provideInput?(promptContext: IBuildPromptContext): Promise<T | undefined>;

	/**
	 * If set, called when the tool is selected in the tool calling loop. Can
	 * resolve LLM-generated input by adding properties or modifying generated
	 * ones.
	 * @param input Input that may have been generated by the model
	 * @param mode The mode in which the tool is being invoked
	 */
	resolveInput?(input: T, promptContext: IBuildPromptContext, mode: CopilotToolMode): Promise<T>;

	/**
	 * Optionally get a programmatic override for the LM tool information. This
	 * can be driven by EXP for example, or customized based on the current model.
	 * ⚠️ A tool using an alternative definition MUST still accept its default
	 * parameters because the alternative definition will only be applied within
	 * the Copilot extension, not other extensions' usages via `vscode.lm.tools`.
	 *
	 * @param tool The original tool definition.
	 * @param endpoint Optional information about the currently selected language model endpoint.
	 *                 If provided, allows customizing the tool definition per endpoint.
	 *
	 * @return An overridden tool definition.
	 * @deprecated use `ToolRegistry.registerModelSpecificTool` instead
	 */
	alternativeDefinition?(tool: vscode.LanguageModelToolInformation, endpoint?: IChatEndpoint): vscode.LanguageModelToolInformation;
}

export interface ICopilotTool<T> extends ICopilotToolExtension<T> {
	invoke?: vscode.LanguageModelTool<T>['invoke'];
	prepareInvocation?: vscode.LanguageModelTool<T>['prepareInvocation'];
}

export interface ICopilotModelSpecificTool<T> extends ICopilotTool<T> {
	/**
	 * If present, this tool should be used instead of the base tool for the given tool name.
	 * Note that this will require the base tool be registered and enabled in the request,
	 * effectively 'overlaying' it.
	 *
	 * Defining `overridesTool` makes the model-specific tool behave substantially different from
	 * normal model specific tools, since it is not individually selectable in the UI.
	 */
	overridesTool?: ToolName;
}

export function isVscodeLanguageModelTool(tool: ICopilotTool<unknown>): tool is vscode.LanguageModelTool<unknown> {
	return typeof tool.invoke === 'function';
}

export interface ICopilotToolCtor {
	readonly toolName: ToolName;
	new(...args: never[]): ICopilotTool<unknown>;
}

export interface IModelSpecificToolCtor {
	new(...args: never[]): ICopilotModelSpecificTool<unknown>;
}

export interface ICopilotToolExtensionCtor extends IModelSpecificToolCtor {
	readonly toolName: ToolName;
	new(...args: never[]): ICopilotToolExtension<unknown>;
}

export const ToolRegistry = new class {
	private _tools: Array<ICopilotToolCtor> = [];
	private _toolExtensions: Array<ICopilotToolExtensionCtor> = [];
	private _modelSpecificTools = new ObservableMap<string, { definition: vscode.LanguageModelToolDefinition; tool: IModelSpecificToolCtor }>();

	public get modelSpecificTools() {
		return this._modelSpecificTools.observable.map(v => [...v.values()]);
	}

	public registerTool(tool: ICopilotToolCtor) {
		this._tools.push(tool);
	}

	public getTools(): readonly ICopilotToolCtor[] {
		return this._tools;
	}

	public registerToolExtension(tool: ICopilotToolExtensionCtor) {
		this._toolExtensions.push(tool);
	}

	public registerModelSpecificTool(definition: vscode.LanguageModelToolDefinition, tool: IModelSpecificToolCtor): IDisposable {
		if (this._modelSpecificTools.has(definition.name)) {
			throw new Error(`Model specific tool for ${definition.name} is already registered`);
		}

		this._modelSpecificTools.set(definition.name, { definition, tool });

		return {
			dispose: () => {
				this._modelSpecificTools.delete(definition.name);
			}
		};
	}

	public getToolExtensions(): readonly ICopilotToolExtensionCtor[] {
		return this._toolExtensions;
	}
}();

export function modelSpecificToolApplies(tool: vscode.LanguageModelToolDefinition, endpoint: IChatEndpoint) {
	if (!tool.models) {
		return true;
	}

	return tool.models.some(m => {
		if (m.id !== undefined && m.id === endpoint.model) {
			return true;
		}
		if (m.version !== undefined && m.version === endpoint.version) {
			return true;
		}
		if (m.family !== undefined && m.family === endpoint.family) {
			return true;
		}

		if (m.vendor !== undefined && m.vendor === endpoint.version) {
			return true;
		}
	});
}