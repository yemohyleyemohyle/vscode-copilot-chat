/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import {
	CancellationToken,
	InlineCompletionContext,
	InlineCompletionEndOfLifeReason,
	InlineCompletionEndOfLifeReasonKind,
	InlineCompletionItem,
	InlineCompletionList,
	InlineCompletionTriggerKind,
	PartialAcceptInfo,
	Position,
	Range,
	TextDocument,
	window
} from 'vscode';
import { ISurveyService } from '../../../../../../platform/survey/common/surveyService';
import { assertNever } from '../../../../../../util/vs/base/common/assert';
import { IInstantiationService } from '../../../../../../util/vs/platform/instantiation/common/instantiation';
import { createCorrelationId } from '../../../../../inlineEdits/common/correlationId';
import { NextEditProviderTelemetryBuilder } from '../../../../../inlineEdits/node/nextEditProviderTelemetry';
import { GhostTextLogContext } from '../../../../common/ghostTextContext';
import { CopilotCompletion } from '../../../lib/src/ghostText/copilotCompletion';
import { handleGhostTextPostInsert, handleGhostTextShown, handlePartialGhostTextPostInsert } from '../../../lib/src/ghostText/last';
import { GhostText } from '../../../lib/src/inlineCompletion';
import { telemetry } from '../../../lib/src/telemetry';
import { wrapDoc } from '../textDocumentManager';

export interface GhostTextCompletionList extends InlineCompletionList {
	items: GhostTextCompletionItem[];
	telemetryBuilder: NextEditProviderTelemetryBuilder;
}

export interface GhostTextCompletionItem extends InlineCompletionItem {
	opportunityId: string;
	copilotCompletion: CopilotCompletion;
	telemetryBuilder: NextEditProviderTelemetryBuilder;
}

export class GhostTextProvider {

	private readonly ghostText: GhostText;

	constructor(
		@IInstantiationService private readonly instantiationService: IInstantiationService,
		@ISurveyService private readonly _surveyService: ISurveyService,
	) {
		this.ghostText = this.instantiationService.createInstance(GhostText);
	}

	async provideInlineCompletionItems(
		vscodeDoc: TextDocument,
		position: Position,
		context: InlineCompletionContext,
		telemetryBuilder: NextEditProviderTelemetryBuilder,
		logContext: GhostTextLogContext,
		token: CancellationToken
	): Promise<GhostTextCompletionList | undefined> {
		const textDocument = wrapDoc(vscodeDoc);
		if (!textDocument) {
			return;
		}

		// Opportunity ID is a unique ID generated by the client relating to a single "opportunity"
		// to provide some kind of suggestion to the user. Multiple requests might be made for a single
		// opportunity, for example requesting a completion as well as an edit suggestion. The single ID
		// allows us to correlate the different requests.
		const opportunityId = context.requestUuid;

		const formattingOptions = window.visibleTextEditors.find(e => e.document.uri === vscodeDoc.uri)?.options;

		const rawCompletions = await this.ghostText.getInlineCompletions(
			textDocument,
			position,
			token,
			{
				isCycling: context.triggerKind === InlineCompletionTriggerKind.Invoke,
				selectedCompletionInfo: context.selectedCompletionInfo,
				formattingOptions,
				opportunityId,
			},
			logContext,
		);

		if (!rawCompletions) {
			return;
		}

		const items: GhostTextCompletionItem[] = rawCompletions.map(completion => {
			const { start, end } = completion.range;
			const newRange = new Range(start.line, start.character, end.line, end.character);
			return {
				opportunityId,
				insertText: completion.insertText,
				range: newRange,
				copilotCompletion: completion,
				correlationId: createCorrelationId('completions', {}),
				telemetryBuilder,
			} satisfies GhostTextCompletionItem;
		});

		return { items, telemetryBuilder } satisfies GhostTextCompletionList;
	}

	handleDidShowCompletionItem(item: GhostTextCompletionItem) {
		this.instantiationService.invokeFunction(handleGhostTextShown, item.copilotCompletion);
	}

	handleDidPartiallyAcceptCompletionItem(item: GhostTextCompletionItem, info: number | PartialAcceptInfo) {
		if (typeof info === 'number') {
			return; // deprecated API
		}
		this.instantiationService.invokeFunction(handlePartialGhostTextPostInsert, item.copilotCompletion, info.acceptedLength);
	}

	async handleEndOfLifetime(completionItem: GhostTextCompletionItem, reason: InlineCompletionEndOfLifeReason) {
		const copilotCompletion = completionItem.copilotCompletion;
		switch (reason.kind) {
			case InlineCompletionEndOfLifeReasonKind.Accepted: {
				completionItem.telemetryBuilder.setAcceptance('accepted');
				this.instantiationService.invokeFunction(handleGhostTextPostInsert, copilotCompletion);
				this._surveyService.signalUsage('completions').catch(() => {
					// Ignore errors from the survey command execution
				});
				return;
			}
			case InlineCompletionEndOfLifeReasonKind.Rejected: {
				completionItem.telemetryBuilder.setAcceptance('rejected');
				this.instantiationService.invokeFunction(telemetry, 'ghostText.dismissed', copilotCompletion.telemetry);
				return;
			}
			case InlineCompletionEndOfLifeReasonKind.Ignored: {
				completionItem.telemetryBuilder.setAcceptance('notAccepted');
				if (reason.supersededBy) {
					const supersededByItem = reason.supersededBy as GhostTextCompletionItem;
					completionItem.telemetryBuilder.setSupersededBy(supersededByItem.opportunityId);
				}
				completionItem.telemetryBuilder.setUserTypingDisagreed(reason.userTypingDisagreed);
				return;
			}
			default: {
				assertNever(reason);
			}
		}
	}
}
